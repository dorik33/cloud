# Для запуска использовать ```make up```
### Балансировщик реализован по алгоритму round-robin, rate limiting с помощью token bucket.
### При запуске сервер слушает по адресу http://localhost:8085, так же дополнительно запускается 2 бекенда для балансировщика на адресах: http://localhost:8001, http://localhost:8004.
### Балансировщик срабатывает по url 
```http://localhost:8085\``` 
### в таком случае rate limit не работает, так же можно передать url параметр client_id, в таком случае с клиента списывается 10 токенов
```http://localhost:8085/?client_id=user3``` 


## Управление клиентами
### Получить список всех клиентов GET http://localhost:8085/clients
### Возвращает массив клиентов
### Пример запроса: ```http://localhost:8085/clients``


### Добавить клиента POST ```http://localhost:8085/clients```
### Принимает тело запроса в виде json
```
{"client_id": "user1", "capacity": 30, "rate_per_sec": 1}
```
### Возвращает созданного клиента
```
{
    "client_id": "user1",
    "capacity": 30,
    "rate_per_sec": 1,
    "tokens": 30,
    "last_refill": "2025-04-29T00:54:59.22710648Z",
    "created_at": "2025-04-29T00:54:59.227106568Z",
    "updated_at": "2025-04-29T00:54:59.227106618Z"
}
```

### Обновить клиента PUT ```http://localhost:8085/clients/user1```
### Принимает тело запроса в виде json
```
   {"capacity": 25, "rate_per_sec": 3}
```
### Возвращает созданного клиента
```
{
    "client_id": "user1",
    "capacity": 25,
    "rate_per_sec": 3,
    "tokens": 25,
    "last_refill": "2025-04-29T00:55:50.99770238Z",
    "created_at": "2025-04-29T00:54:59.227106Z",
    "updated_at": "2025-04-29T00:55:50.997734Z"
}
```
###Удалить клиента DELETE ```http://localhost:8085/clients/user1```

# Ответы на вопросы
## 1. Опишите самую интересную задачу в программировании, которую вам приходилось решать?
###   Самой интересной задачей была реализация системы аутентификации с JWT Refresh Token для REST API на Go. Пользователи получали Access Token действовал 16 минут и Refresh Token, который действует несколько недель после входа. Refresh Token позволял обновлять Access Token без повторного ввода пароля. Самое интересное было настраивать безопасное хранение Refresh Token в базе PostgreSQL и проверку их валидности, чтобы защитить API от несанкционированного доступа.
## 2. Расскажите о своем самом большом факапе? Что вы предприняли для решения проблемы?
### Мой самый большой факап был в формате моего обучения, я очень много изучал различной теории и мало писал кода. Сейчас я стараюсь больше уделять внимания именно практики, пишу проекты с различными технологиями.  
## 3. Каковы ваши ожидания от участия в буткемпе?
### По окончании буткема я хочу усовершествовать свои навыки в написании чистого и тестируемого кода, который будет понятным другим разработчикам, так же в будущем я бы хотел попасть в основную команду cloud.ru и развиваться вместе с этой компанией.
